"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var throat_1 = require("throat");
exports.default = {
    Finally: Finally,
    Try: Try,
    defer: defer,
    deferSet: deferSet,
    delay: delay,
    delayChain: delayChain,
    each: each,
    filter: filter,
    finally: Finally,
    finallyDelay: finallyDelay,
    funnel: funnel,
    inspect: inspect,
    map: map,
    once: once,
    props: props,
    reduce: reduce,
    rethrow: rethrow,
    retry: retry,
    some: some,
    specific: specific,
    tap: tap,
    wrapFunction: wrapFunction,
};
function toReadonlyArray(arr) {
    /* istanbul ignore else */
    if (typeof arr.map === "function")
        return arr;
    else
        return Array.from(arr);
}
function delay(milliseconds, t) {
    return new Promise(function (resolve, reject) {
        setTimeout(function () { return resolve(t); }, milliseconds);
    });
}
exports.delay = delay;
function delayChain(milliseconds) {
    return tap(function () { return delay(milliseconds); });
}
exports.delayChain = delayChain;
function finallyDelay(milliseconds) {
    return Finally(function () { return delay(milliseconds); });
}
exports.finallyDelay = finallyDelay;
function Finally(fn) {
    function _then(t) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fn()];
                    case 1:
                        _a.sent();
                        return [2 /*return*/, t];
                }
            });
        });
    }
    function _catch(err) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, fn()];
                    case 1:
                        _a.sent();
                        throw err;
                }
            });
        });
    }
    return [_then, _catch];
}
exports.Finally = Finally;
function tap(fn) {
    var _this = this;
    return function (t) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fn(t)];
                case 1:
                    _a.sent();
                    return [2 /*return*/, t];
            }
        });
    }); };
}
exports.tap = tap;
function props(obj) {
    var ret = {};
    var awaiters = [];
    var _loop_1 = function (prop) {
        awaiters.push(Promise.resolve(obj[prop])
            .then(function (val) { ret[prop] = val; }));
    };
    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
        var prop = _a[_i];
        _loop_1(prop);
    }
    return Promise.all(awaiters).then(function () { return ret; });
}
exports.props = props;
var defaultFilterMapOptions = { concurrency: Infinity };
function filter(arr, opts, filterFn) {
    if (Array.isArray(arr)) {
        if (typeof opts === "function") {
            filterFn = opts;
            opts = defaultFilterMapOptions;
        }
        var intermediate = filter(opts, filterFn);
        return intermediate(arr);
    }
    filterFn = typeof arr === "function" ? arr : opts;
    opts =
        typeof arr === "function"
            ? defaultFilterMapOptions
            : arr;
    var wrappedFilterFn = function (val, index, arr) {
        return Promise.resolve(filterFn(val, index, arr))
            .then(function (ok) { return ({ ok: ok, val: val }); });
    };
    return function (t) {
        return map(opts, wrappedFilterFn)(t)
            .then(function (values) {
            return values
                .filter(function (_a) {
                var ok = _a.ok;
                return ok;
            })
                .map(function (_a) {
                var val = _a.val;
                return val;
            });
        });
    };
}
exports.filter = filter;
function map(arr, opts, mapFn) {
    if (Array.isArray(arr)) {
        if (typeof opts === "function") {
            mapFn = opts;
            opts = defaultFilterMapOptions;
        }
        return map(opts, mapFn)(arr);
    }
    mapFn = typeof arr === "function" ? arr : opts;
    opts =
        typeof arr === "function"
            ? defaultFilterMapOptions
            : arr;
    var _a = opts.concurrency, concurrency = _a === void 0 ? Infinity : _a;
    var promiseMapFn = function (t, index, arr) {
        return Promise.resolve(mapFn(t, index, arr));
    };
    var throated = throat_1.default(concurrency);
    return function (t) {
        return Promise.resolve(t)
            .then(function (values) {
            return toReadonlyArray(values).map(function (val, index, arr) {
                return throated(function () { return Promise.resolve(val); })
                    .then(function (val) {
                    return throated(function () { return promiseMapFn(val, index, arr); });
                });
            });
        })
            .then(function (values) { return Promise.all(values); });
    };
}
exports.map = map;
function reduce(input, reducer, initialValue) {
    var _this = this;
    if (typeof input === "function") {
        initialValue = reducer;
        var _reducer_1 = input;
        return function (input) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, reduceImpl(input, _reducer_1, initialValue)];
            });
        }); };
    }
    return reduceImpl(input, reducer, initialValue);
}
exports.reduce = reduce;
function reduceImpl(input, reducer, initialValue) {
    return __awaiter(this, void 0, void 0, function () {
        var _input, _a, _b, _initialValue, usingInitialValue, length, index, accumulator, _c, _d, _e;
        return __generator(this, function (_f) {
            switch (_f.label) {
                case 0:
                    _b = (_a = Array).from;
                    return [4 /*yield*/, input];
                case 1:
                    _input = _b.apply(_a, [_f.sent()]);
                    return [4 /*yield*/, initialValue];
                case 2:
                    _initialValue = _f.sent();
                    if (_input.length === 0)
                        return [2 /*return*/, _initialValue];
                    usingInitialValue = typeof _initialValue !== "undefined";
                    length = _input.length;
                    index = usingInitialValue ? 0 : 1;
                    if (!usingInitialValue) return [3 /*break*/, 3];
                    _c = _initialValue;
                    return [3 /*break*/, 5];
                case 3: return [4 /*yield*/, _input.shift()];
                case 4:
                    _c = _f.sent();
                    _f.label = 5;
                case 5:
                    accumulator = _c;
                    _f.label = 6;
                case 6:
                    if (!(_input.length > 0)) return [3 /*break*/, 9];
                    _d = reducer;
                    _e = [accumulator];
                    return [4 /*yield*/, _input.shift()];
                case 7: return [4 /*yield*/, _d.apply(void 0, _e.concat([_f.sent(), index++, length]))];
                case 8:
                    accumulator = _f.sent();
                    return [3 /*break*/, 6];
                case 9: return [2 /*return*/, accumulator];
            }
        });
    });
}
function each(arr, eachFn) {
    if (Array.isArray(arr))
        return eachImpl(eachFn)(arr);
    return eachImpl(arr);
}
exports.each = each;
function eachImpl(eachFn) {
    var _this = this;
    return function (arr) { return __awaiter(_this, void 0, void 0, function () {
        function iterator(t, index) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, eachFn(t, index, length)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/, t];
                    }
                });
            });
        }
        var length;
        return __generator(this, function (_a) {
            length = arr.length;
            return [2 /*return*/, map(arr, { concurrency: 1 }, iterator)];
        });
    }); };
}
exports.eachImpl = eachImpl;
function some(list, fn) {
    if (typeof list === "function") {
        fn = list;
        return function (list) {
            return someImpl(list, fn);
        };
    }
    return someImpl(list, fn);
}
exports.some = some;
function someImpl(list, fn) {
    return __awaiter(this, void 0, void 0, function () {
        var _list, _a, _i, _list_1, val, ret, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _a = toReadonlyArray;
                    return [4 /*yield*/, list];
                case 1:
                    _list = _a.apply(void 0, [_c.sent()]);
                    _i = 0, _list_1 = _list;
                    _c.label = 2;
                case 2:
                    if (!(_i < _list_1.length)) return [3 /*break*/, 6];
                    val = _list_1[_i];
                    _b = fn;
                    return [4 /*yield*/, val];
                case 3: return [4 /*yield*/, _b.apply(void 0, [_c.sent()])];
                case 4:
                    ret = _c.sent();
                    if (ret)
                        return [2 /*return*/, ret];
                    _c.label = 5;
                case 5:
                    _i++;
                    return [3 /*break*/, 2];
                case 6: return [2 /*return*/, false];
            }
        });
    });
}
function once(fn) {
    if (fn) {
        var _once_1 = onceDynamic();
        return function () { return _once_1(fn); };
    }
    else
        return onceDynamic();
}
exports.once = once;
function onceDynamic() {
    var state = new WeakMap();
    var ensureState = function (fn) {
        if (!state.has(fn))
            state.set(fn, { hasRun: false });
    };
    return function (fn) {
        ensureState(fn);
        var stateObject = state.get(fn);
        if (stateObject.hasRun) {
            if (stateObject.deferred)
                return stateObject.deferred.promise;
            return stateObject.returnValue;
        }
        stateObject.hasRun = true;
        var ret = fn();
        var pret = ret;
        if (pret !== undefined && pret && typeof pret.then === "function") {
            stateObject.deferred = defer(void 0);
            return pret
                .then(stateObject.deferred.resolve, rethrow(stateObject.deferred.reject))
                .then(function () {
                return stateObject.deferred.promise;
            });
        }
        stateObject.returnValue = ret;
        return ret;
    };
}
function retry(times, fn, retryable) {
    if (retryable === void 0) { retryable = function () { return true; }; }
    var retryAsync = function (promise) {
        return promise
            .catch(function (err) {
            if (--times < 0 || !retryable(err))
                throw err;
            return retryAsync(fn());
        });
    };
    var retrySync = function (_err) {
        while (--times >= 0) {
            try {
                return fn();
            }
            catch (err) {
                if (!retryable(err))
                    throw err;
                _err = err;
            }
        }
        throw _err;
    };
    try {
        var ret = fn();
        if (ret &&
            typeof ret === "object" &&
            typeof ret.then === "function") {
            return retryAsync(ret);
        }
        return ret;
    }
    catch (err) {
        if (!retryable(err))
            throw err;
        return retrySync(err);
    }
}
exports.retry = retry;
function defer() {
    var deferred = {};
    deferred.promise = new Promise(function (resolve, reject) {
        deferred.resolve = resolve;
        deferred.reject = reject;
    });
    return deferred;
}
exports.defer = defer;
function reflect(promise) {
    var inspection = inspect(promise);
    function handleResolution(value) {
        return {
            isRejected: false,
            isResolved: true,
            value: value,
        };
    }
    function handleRejection(error) {
        return {
            error: error,
            isRejected: true,
            isResolved: false,
        };
    }
    return inspection.promise
        .then(handleResolution, handleRejection);
}
exports.reflect = reflect;
function inspect(promise) {
    var inspectable = {
        isPending: true,
        isRejected: false,
        isResolved: false,
        promise: void 0,
    };
    inspectable.promise = promise.then(function (value) {
        inspectable.isResolved = true;
        inspectable.isPending = false;
        return value;
    })
        .catch(function (err) {
        inspectable.isRejected = true;
        inspectable.isPending = false;
        return Promise.reject(err);
    });
    return inspectable;
}
exports.inspect = inspect;
function deferInspectable() {
    var deferred = defer();
    var ret = {
        isPending: true,
        isRejected: false,
        isResolved: false,
        promise: deferred.promise,
        resolve: function (t) {
            if (!ret.isPending)
                return;
            deferred.resolve(t);
            ret.isPending = false;
            ret.isRejected = false;
            ret.isResolved = true;
        },
        reject: function (err) {
            if (!ret.isPending)
                return;
            deferred.reject(err);
            ret.isPending = false;
            ret.isRejected = true;
            ret.isResolved = false;
        },
    };
    return ret;
}
exports.deferInspectable = deferInspectable;
function Try(cb) {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            return [2 /*return*/, cb()];
        });
    });
}
exports.Try = Try;
// This logic is taken from Bluebird
function catchFilter(filters, err) {
    return (Array.isArray(filters) ? filters : [filters])
        .some(function (filter) {
        if (filter == null)
            return false;
        if (filter === Error ||
            filter.prototype instanceof Error) {
            if (err instanceof filter)
                return true;
        }
        else if (typeof filter === "function") {
            var filterFn = filter;
            // It is "ok" for this to throw. It'll be thrown back to the catch
            // handler, and the promise chain will contain this error.
            return filterFn(err);
        }
        else if (typeof filter === "object") {
            var obj = filter;
            for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {
                var key = _a[_i];
                if (obj[key] !== err[key])
                    return false;
            }
            return true;
        }
        return false;
    });
}
function specific(filters, handler) {
    return function (err) {
        if (!catchFilter(filters, err))
            throw err;
        return handler(err);
    };
}
exports.specific = specific;
function rethrow(fn) {
    var _this = this;
    return function (err) { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, fn(err)];
                case 1:
                    _a.sent();
                    throw err;
            }
        });
    }); };
}
exports.rethrow = rethrow;
function wrapFunction(wrap) {
    // tslint:disable-next-line
    return function (t, cb) {
        var _a, _b;
        var _this = this;
        if (arguments.length === 1) {
            if (wrap.length > 0)
                throw new EvalError("Invalid invocation, function requires 2 arguments");
            cb = t;
            t = void 0;
        }
        var anyCleanup = wrap(t);
        var callCleanup = function (cleanup) {
            if (typeof cleanup === "function")
                return cleanup();
            else if (cleanup != null)
                // Allow 'before' to just return null/undefined, but non-empty
                // value would've been silently ignored.
                throw new EvalError("Invalid return value in 'before' handler");
        };
        if (anyCleanup &&
            typeof anyCleanup.then === "function") {
            var doCleanup_1;
            return (_a = anyCleanup
                .then(function (cleanup) { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    doCleanup_1 = function () { return callCleanup(cleanup); };
                    return [2 /*return*/, cb()];
                });
            }); })).then.apply(_a, Finally(function () {
                if (doCleanup_1)
                    return doCleanup_1();
            }));
        }
        else {
            var cleanup_1 = anyCleanup;
            var cbRet_1;
            try {
                cbRet_1 = cb();
            }
            catch (err) {
                var cleanupRet = callCleanup(cleanup_1);
                if (cleanupRet &&
                    typeof cleanupRet.then === "function") {
                    return cleanupRet
                        .then(function () { throw err; });
                }
                else {
                    throw err;
                }
            }
            if (cbRet_1 && typeof cbRet_1.then === "function") {
                return (_b = cbRet_1).then.apply(_b, Finally(function () { return callCleanup(cleanup_1); }));
            }
            else {
                var cleanupRet = callCleanup(cleanup_1);
                if (cleanupRet &&
                    typeof cleanupRet.then === "function") {
                    return cleanupRet
                        .then(function () { return cbRet_1; });
                }
                else {
                    return cbRet_1;
                }
            }
        }
    };
}
exports.wrapFunction = wrapFunction;
function funnel(opts) {
    if (opts === void 0) { opts = {}; }
    var _a = (opts || {}), _b = _a.onComplete, onComplete = _b === void 0 ? function () { } : _b, _c = _a.fifo, fifo = _c === void 0 ? true : _c;
    var _onComplete = function () { return onComplete && onComplete(); };
    var waiters = [];
    var retryers = new WeakMap();
    var stores = new Set();
    var waitFor = function (t) {
        waiters.push(t);
    };
    var hasSiblingFirst = function (store) {
        if (waiters.length === 0)
            return false;
        var firstStoreInCall = store.call[0];
        return waiters[0] === firstStoreInCall;
    };
    var completeStore = function (store) {
        var indexCall = store.call.indexOf(store);
        store.call.splice(indexCall, 1);
        var indexWaiters = waiters.indexOf(store);
        waiters.splice(indexWaiters, 1);
        stores.delete(store);
        return store.call.length === 0;
    };
    var triggerWaiter = function () {
        if (waiters.length === 0 && stores.size === 0)
            _onComplete();
        else {
            var first = waiters[0];
            var nextRetryer = retryers.get(first);
            nextRetryer && nextRetryer();
        }
    };
    var finalizeRetry = function (store) {
        var completed = completeStore(store);
        if (completed)
            triggerWaiter();
    };
    var runner = function (fn, call) {
        var fnDeferred = defer();
        var store = {
            call: call,
            ret: fnDeferred.promise,
        };
        call.push(store);
        stores.add(store);
        var hasPassedRetry = false;
        var hasFinalized = false;
        var finalize = function () {
            if (hasFinalized)
                return;
            hasFinalized = true;
            finalizeRetry(store);
        };
        var shouldRetry = function () {
            var _a;
            var firstAndOnly = waiters.length === 0;
            var firstInQueue = hasSiblingFirst(store);
            var result = firstAndOnly || firstInQueue;
            if (result && !fifo)
                waitFor(store);
            if (result) {
                hasPassedRetry = true;
                // If first in queue, schedule waiting for the return promise
                // to trigger the rest of the queue.
                (_a = store.ret).then.apply(_a, Finally(finalize)).catch(function (err) { });
            }
            return !result;
        };
        var retry = function () {
            var _a;
            var deferred = defer();
            var retryer = function () { return deferred.resolve(runner(fn, call)); };
            retryers.set(store, retryer);
            if (!fifo)
                waitFor(store);
            hasPassedRetry = true;
            // When retrying, when the final result is finally complete, it's
            // always first in queue.
            (_a = deferred.promise).then.apply(_a, Finally(finalize));
            return deferred.promise;
        };
        var shortcut = function () {
            if (hasPassedRetry)
                finalize();
        };
        if (fifo)
            waitFor(store);
        Try(function () { return fn(shouldRetry, retry, shortcut); })
            .then(fnDeferred.resolve, fnDeferred.reject);
        return store.ret;
    };
    return function (fn) {
        return runner(fn, []);
    };
}
exports.funnel = funnel;
var OrderedAsynchrony = /** @class */ (function () {
    function OrderedAsynchrony() {
        this.deferrals = [];
    }
    OrderedAsynchrony.prototype.wait = function (waitForIndex, resolveIndex, rejectIndex) {
        var _this = this;
        this.ensureDeferral(([].concat(waitForIndex)).concat((resolveIndex == null ? [] :
            [].concat(resolveIndex)), (rejectIndex == null ? [] :
            [].concat(rejectIndex))));
        return this.decorate(Promise.all([].concat(waitForIndex)
            .map(function (index) { return _this.deferrals[index].promise; }))
            .then(function () {
            return Promise.all([
                resolveIndex == null
                    ? void 0
                    : _this.resolve(resolveIndex),
                rejectIndex == null
                    ? void 0
                    : _this.reject(rejectIndex),
            ])
                .then(function () { });
        }));
    };
    OrderedAsynchrony.prototype.resolve = function (index) {
        var _this = this;
        this.ensureDeferral(index);
        return this.decorate(delay(0).then(function () {
            [].concat(index)
                .forEach(function (index) {
                _this.deferrals[index].resolve();
            });
        }));
    };
    OrderedAsynchrony.prototype.reject = function (index, error) {
        var _this = this;
        if (error === void 0) { error = new Error("OrderedAsynchrony rejection"); }
        this.ensureDeferral(index);
        return this.decorate(delay(0).then(function () {
            [].concat(index)
                .forEach(function (index) {
                _this.deferrals[index].reject(error);
            });
        }));
    };
    OrderedAsynchrony.prototype.ensureDeferral = function (index) {
        var indices = []
            .concat(index)
            .sort(function (a, b) { return b - a; });
        var highest = indices[0];
        for (var i = this.deferrals.length; i <= highest; ++i)
            this.deferrals.push(defer(void 0));
        return this;
    };
    OrderedAsynchrony.prototype.decorate = function (promise) {
        // tslint:disable-next-line:variable-name
        var This = {
            decorate: this.decorate.bind(this),
            deferrals: this.deferrals,
            ensureDeferral: this.ensureDeferral.bind(this),
            reject: this.reject.bind(this),
            resolve: this.resolve.bind(this),
            wait: this.wait.bind(this),
        };
        return Object.assign(promise, This);
    };
    return OrderedAsynchrony;
}());
exports.OrderedAsynchrony = OrderedAsynchrony;
function deferSet() {
    return new OrderedAsynchrony();
}
exports.deferSet = deferSet;
//# sourceMappingURL=index.js.map