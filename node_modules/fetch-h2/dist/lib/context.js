"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const context_http1_1 = require("./context-http1");
const context_http2_1 = require("./context-http2");
const context_https_1 = require("./context-https");
const cookie_jar_1 = require("./cookie-jar");
const core_1 = require("./core");
const fetch_http1_1 = require("./fetch-http1");
const fetch_http2_1 = require("./fetch-http2");
const version_1 = require("./generated/version");
const request_1 = require("./request");
const utils_1 = require("./utils");
function makeDefaultUserAgent() {
    const name = `fetch-h2/${version_1.version} (+https://github.com/grantila/fetch-h2)`;
    const node = `nodejs/${process.versions.node}`;
    const nghttp2 = `nghttp2/${process.versions.nghttp2}`;
    const uv = `uv/${process.versions.uv}`;
    return `${name} ${node} ${nghttp2} ${uv}`;
}
const defaultUserAgent = makeDefaultUserAgent();
const defaultAccept = "application/json, text/*;0.9, */*;q=0.8";
class Context {
    constructor(opts) {
        this._userAgent = "";
        this._overwriteUserAgent = false;
        this._accept = "";
        this._cookieJar = void 0;
        this._decoders = [];
        this._sessionOptions = {};
        this._httpProtocol = "http1";
        this._httpsProtocols = ["http2", "http1"];
        this._http1Options = {};
        this.setup(opts);
        this.h1Context = new context_http1_1.H1Context(this._http1Options);
        this.h2Context = new context_http2_1.H2Context(this.decoders.bind(this), this.sessionOptions.bind(this));
    }
    setup(opts) {
        opts = opts || {};
        this._cookieJar = "cookieJar" in opts
            ? (opts.cookieJar || new cookie_jar_1.CookieJar())
            : new cookie_jar_1.CookieJar();
        this._userAgent = core_1.parsePerOrigin(opts.userAgent, "");
        this._overwriteUserAgent =
            core_1.parsePerOrigin(opts.overwriteUserAgent, false);
        this._accept = core_1.parsePerOrigin(opts.accept, defaultAccept);
        this._decoders = core_1.parsePerOrigin(opts.decoders, []);
        this._sessionOptions = core_1.parsePerOrigin(opts.session, {});
        this._httpProtocol = core_1.parsePerOrigin(opts.httpProtocol, "http1");
        this._httpsProtocols = core_1.parsePerOrigin(opts.httpsProtocols, ["http2", "http1"]);
        Object.assign(this._http1Options, opts.http1 || {});
    }
    userAgent(origin) {
        const combine = (userAgent, overwriteUserAgent) => {
            const defaultUA = overwriteUserAgent ? "" : defaultUserAgent;
            return userAgent
                ? defaultUA
                    ? userAgent + " " + defaultUA
                    : userAgent
                : defaultUA;
        };
        return combine(core_1.getByOrigin(this._userAgent, origin), core_1.getByOrigin(this._overwriteUserAgent, origin));
    }
    decoders(origin) {
        return core_1.getByOrigin(this._decoders, origin);
    }
    sessionOptions(origin) {
        return core_1.getByOrigin(this._sessionOptions, origin);
    }
    onPush(pushHandler) {
        this.h2Context._pushHandler = pushHandler;
    }
    async fetch(input, init) {
        const { hostname, origin, port, protocol, url } = this.parseInput(input);
        // Rewrite url to get rid of "http1://" and "http2://"
        const request = input instanceof request_1.Request
            ? input.url !== url
                ? input.clone(url)
                : input
            : new request_1.Request(input, { ...(init || {}), url });
        const { rejectUnauthorized } = this.sessionOptions(origin);
        const makeSimpleSession = (protocol) => ({
            accept: () => core_1.getByOrigin(this._accept, origin),
            contentDecoders: () => core_1.getByOrigin(this._decoders, origin),
            cookieJar: this._cookieJar,
            protocol,
            userAgent: () => this.userAgent(origin),
        });
        const doFetchHttp1 = (socket, cleanup) => {
            const sessionGetterHttp1 = {
                get: (url) => ({
                    cleanup,
                    req: this.getHttp1(url, socket, request, rejectUnauthorized),
                }),
                ...makeSimpleSession("http1"),
            };
            return fetch_http1_1.fetch(sessionGetterHttp1, request, init);
        };
        const doFetchHttp2 = () => {
            const sessionGetterHttp2 = {
                get: (url) => this.getHttp2(url),
                ...makeSimpleSession("http2"),
            };
            return fetch_http2_1.fetch(sessionGetterHttp2, request, init);
        };
        const tryWaitForHttp1 = async () => {
            const { socket: freeHttp1Socket, cleanup, shouldCreateNew } = this.h1Context.getFreeSocketForOrigin(origin);
            if (freeHttp1Socket)
                return doFetchHttp1(freeHttp1Socket, cleanup);
            if (!shouldCreateNew) {
                // We've maxed out HTTP/1 connections, wait for one to be
                // freed.
                const { socket, cleanup } = await this.h1Context.waitForSocket(origin);
                return doFetchHttp1(socket, cleanup);
            }
        };
        if (protocol === "http1") {
            // Plain text HTTP/1(.1)
            const resp = await tryWaitForHttp1();
            if (resp)
                return resp;
            const socket = await this.h1Context.makeNewConnection(url);
            const cleanup = this.h1Context.addUsedSocket(origin, socket);
            return doFetchHttp1(socket, cleanup);
        }
        else if (protocol === "http2") {
            // Plain text HTTP/2
            return doFetchHttp2();
        }
        else // protocol === "https"
         {
            // If we already have a session/socket open to this origin,
            // re-use it
            if (this.h2Context.hasOrigin(origin))
                return doFetchHttp2();
            const resp = await tryWaitForHttp1();
            if (resp)
                return resp;
            // TODO: Make queue for subsequent fetch requests to the same
            //       origin, so they can re-use the http2 session, or http1
            //       pool once we know what protocol will be used.
            //       This must apply to plain-text http1 too.
            // Use ALPN to figure out protocol lazily
            const { protocol, socket } = await context_https_1.connectTLS(hostname, port, core_1.getByOrigin(this._httpsProtocols, origin), core_1.getByOrigin(this._sessionOptions, origin));
            if (protocol === "http2") {
                // Convert socket into http2 session, this will ref (*)
                const { cleanup } = await this.h2Context.getOrCreateHttp2(origin, {
                    createConnection: () => socket,
                });
                // Session now lingering, it will be re-used by the next get()
                const ret = doFetchHttp2();
                // Unref lingering ref
                cleanup();
                return ret;
            }
            else // protocol === "http1"
             {
                const cleanup = this.h1Context.addUsedSocket(origin, socket);
                return doFetchHttp1(socket, cleanup);
            }
        }
    }
    async disconnect(url) {
        await Promise.all([
            this.h1Context.disconnect(url),
            this.h2Context.disconnect(url),
        ]);
    }
    async disconnectAll() {
        await Promise.all([
            this.h1Context.disconnectAll(),
            this.h2Context.disconnectAll(),
        ]);
    }
    getHttp1(url, socket, request, rejectUnauthorized) {
        return this.h1Context.connect(new url_1.URL(url), {
            createConnection: () => socket,
            rejectUnauthorized,
        }, request);
    }
    getOrCreateHttp2(origin, created = false) {
        const { didCreate, session, cleanup } = this.h2Context.getOrCreateHttp2(origin);
        return session
            .catch(err => {
            if (didCreate || created)
                // Created in this request, forward error
                throw err;
            // Not created in this request, try again
            return this.getOrCreateHttp2(origin, true)
                .then(({ session }) => session);
        })
            .then(session => ({ session, cleanup }));
    }
    getHttp2(url) {
        const { origin } = typeof url === "string" ? new url_1.URL(url) : url;
        return this.getOrCreateHttp2(origin);
    }
    parseInput(input) {
        const { hostname, origin, port, protocol, url } = utils_1.parseInput(typeof input !== "string" ? input.url : input);
        const defaultHttp = this._httpProtocol;
        if ((protocol === "http" && defaultHttp === "http1")
            || protocol === "http1")
            return {
                hostname,
                origin,
                port,
                protocol: "http1",
                url,
            };
        else if ((protocol === "http" && defaultHttp === "http2")
            || protocol === "http2")
            return {
                hostname,
                origin,
                port,
                protocol: "http2",
                url,
            };
        else if (protocol === "https")
            return {
                hostname,
                origin,
                port,
                protocol: "https",
                url,
            };
        else
            throw new core_1.FetchError(`Invalid protocol "${protocol}"`);
    }
}
exports.Context = Context;
//# sourceMappingURL=context.js.map