"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const get_stream_1 = require("get-stream");
const through2 = require("through2");
const utils_1 = require("../lib/utils");
const index_1 = require("../../index");
async function makeSync(fn) {
    try {
        const val = await fn();
        return () => val;
    }
    catch (err) {
        return () => { throw err; };
    }
}
function setHash(body, data, hashType = "sha256") {
    body._integrity = utils_1.createIntegrity(data, hashType);
}
class IntegrityBody extends index_1.Body {
    constructor(data, hashData, integrityHashType = "sha256") {
        super();
        const hash = crypto_1.createHash("sha256");
        hash.update(hashData);
        const v = integrityHashType + "-" + hash.digest("base64");
        this.setBody(data, null, v);
    }
}
describe("body", () => {
    describe("multiple reads", () => {
        it("throw on multiple reads", async () => {
            const body = new index_1.DataBody("foo");
            expect(body.bodyUsed).toBe(false);
            expect(await body.text()).toBe("foo");
            expect(body.bodyUsed).toBe(true);
            expect(await makeSync(() => body.text()))
                .toThrow(ReferenceError);
        });
    });
    describe("unimplemented", () => {
        it("throw on unimplemented blob()", async () => {
            const body = new index_1.DataBody("foo");
            expect(await makeSync(() => body.blob()))
                .toThrow();
        });
        it("throw on unimplemented formData()", async () => {
            const body = new index_1.DataBody("foo");
            expect(await makeSync(() => body.formData())).toThrow();
        });
    });
    describe("invalid data", () => {
        it("handle invalid body type when reading as arrayBuffer", async () => {
            const body = new index_1.DataBody(1);
            expect(await makeSync(() => body.arrayBuffer()))
                .toThrow("Unknown body data");
        });
        it("handle invalid body type when reading as json", async () => {
            const body = new index_1.DataBody(1);
            expect(await makeSync(() => body.json()))
                .toThrow("Unknown body data");
        });
        it("handle invalid body type when reading as text", async () => {
            const body = new index_1.DataBody(1);
            expect(await makeSync(() => body.text()))
                .toThrow("Unknown body data");
        });
        it("handle invalid body type when reading as readable", async () => {
            const body = new index_1.DataBody(1);
            expect(await makeSync(() => body.readable()))
                .toThrow("Unknown body data");
        });
    });
    describe("arrayBuffer", () => {
        describe("without validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe("");
            });
            it("handle string", async () => {
                const body = new index_1.DataBody("foo");
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe("foo");
            });
            it("handle buffer", async () => {
                const body = new index_1.DataBody(Buffer.from("foo"));
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe("foo");
            });
            it("handle JsonBody", async () => {
                const body = new index_1.JsonBody({ foo: "bar" });
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe('{"foo":"bar"}');
            });
            it("handle stream", async () => {
                const stream = through2();
                stream.end("foo");
                const body = new index_1.StreamBody(stream);
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe("foo");
            });
        });
        describe("matching validation", () => {
            it("handle null", async () => {
                const body = new IntegrityBody(null, "");
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe("");
            });
            it("handle string", async () => {
                const testData = "foo";
                const body = new IntegrityBody(testData, testData);
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe(testData);
            });
            it("handle buffer", async () => {
                const testData = "foo";
                const body = new IntegrityBody(Buffer.from(testData), testData);
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe(testData);
            });
            it("handle stream", async () => {
                const testData = "foo";
                const stream = through2();
                stream.end(testData);
                const body = new IntegrityBody(stream, testData);
                const data = Buffer.from(await body.arrayBuffer());
                expect(data.toString()).toBe(testData);
            });
        });
        describe("mismatching validation", () => {
            it("handle invalid hash type", async () => {
                const body = new IntegrityBody(null, "", "acme-hash");
                expect(await makeSync(() => body.arrayBuffer()))
                    .toThrow("not supported");
            });
            it("handle null", async () => {
                const body = new IntegrityBody(null, "" + "x");
                expect(await makeSync(() => body.arrayBuffer()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle string", async () => {
                const testData = "foo";
                const body = new IntegrityBody(testData, testData + "x");
                expect(await makeSync(() => body.arrayBuffer()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle buffer", async () => {
                const testData = "foo";
                const body = new IntegrityBody(Buffer.from(testData), testData + "x");
                expect(await makeSync(() => body.arrayBuffer()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle stream", async () => {
                const testData = "foo";
                const stream = through2();
                stream.end(testData);
                const body = new IntegrityBody(stream, testData + "x");
                expect(await makeSync(() => body.arrayBuffer()))
                    .toThrow("Resource integrity mismatch");
            });
        });
    });
    describe("json", () => {
        describe("without validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                expect(await body.json()).toBe(null);
            });
            it("handle invalid string", async () => {
                const body = new index_1.DataBody("invalid json");
                expect(await makeSync(() => body.json())).toThrow();
            });
            it("handle valid string", async () => {
                const body = new index_1.DataBody('{"foo":"bar"}');
                expect(await body.json()).toEqual({ foo: "bar" });
            });
            it("handle invalid buffer", async () => {
                const body = new index_1.DataBody(Buffer.from("invalid json"));
                expect(await makeSync(() => body.json())).toThrow();
            });
            it("handle valid buffer", async () => {
                const body = new index_1.DataBody(Buffer.from('{"foo":"bar"}'));
                expect(await body.json()).toEqual({ foo: "bar" });
            });
            it("handle valid JsonBody", async () => {
                const body = new index_1.JsonBody({ foo: "bar" });
                expect(await body.json()).toEqual({ foo: "bar" });
            });
            it("handle invalid stream", async () => {
                const stream = through2();
                stream.end("invalid json");
                const body = new index_1.StreamBody(stream);
                expect(await makeSync(() => body.json())).toThrow();
            });
            it("handle valid stream", async () => {
                const stream = through2();
                stream.end('{"foo":"bar"}');
                const body = new index_1.StreamBody(stream);
                expect(await body.json()).toEqual({ foo: "bar" });
            });
        });
        describe("matching validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                setHash(body, "");
                expect(await body.json()).toBe(null);
            });
            it("handle string", async () => {
                const testData = '{"foo":"bar"}';
                const body = new index_1.DataBody(testData);
                setHash(body, testData);
                expect(await body.json()).toEqual({ foo: "bar" });
            });
            it("handle buffer", async () => {
                const testData = '{"foo":"bar"}';
                const body = new index_1.DataBody(Buffer.from(testData));
                setHash(body, testData);
                expect(await body.json()).toEqual({ foo: "bar" });
            });
            it("handle JsonBody", async () => {
                const body = new index_1.JsonBody({ foo: "bar" });
                setHash(body, '{"foo":"bar"}');
                expect(await body.json()).toEqual({ foo: "bar" });
            });
            it("handle stream", async () => {
                const testData = '{"foo":"bar"}';
                const stream = through2();
                stream.end(testData);
                const body = new index_1.StreamBody(stream);
                setHash(body, testData);
                expect(await body.json()).toEqual({ foo: "bar" });
            });
        });
        describe("mismatching validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                setHash(body, "" + "x");
                expect(await makeSync(() => body.json()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle string", async () => {
                const testData = '{"foo":"bar"}';
                const body = new index_1.DataBody(testData);
                setHash(body, testData + "x");
                expect(await makeSync(() => body.json()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle buffer", async () => {
                const testData = '{"foo":"bar"}';
                const body = new index_1.DataBody(Buffer.from(testData));
                setHash(body, testData + "x");
                expect(await makeSync(() => body.json()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle JsonBody", async () => {
                const body = new index_1.JsonBody({ foo: "bar" });
                setHash(body, '{"foo":"bar"}' + "x");
                expect(await makeSync(() => body.json()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle stream", async () => {
                const testData = '{"foo":"bar"}';
                const stream = through2();
                stream.end(testData);
                const body = new index_1.StreamBody(stream);
                setHash(body, testData + "x");
                expect(await makeSync(() => body.json()))
                    .toThrow("Resource integrity mismatch");
            });
        });
    });
    describe("text", () => {
        describe("without validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                expect(await body.text()).toBe(null);
            });
            it("handle string", async () => {
                const body = new index_1.DataBody("foo");
                expect(await body.text()).toBe("foo");
            });
            it("handle buffer", async () => {
                const body = new index_1.DataBody(Buffer.from("foo"));
                expect(await body.text()).toBe("foo");
            });
            it("handle stream", async () => {
                const stream = through2();
                stream.end("foo");
                const body = new index_1.StreamBody(stream);
                expect(await body.text()).toBe("foo");
            });
        });
        describe("matching validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                setHash(body, "");
                expect(await body.text()).toBe(null);
            });
            it("handle string", async () => {
                const testData = "foo";
                const body = new index_1.DataBody(testData);
                setHash(body, testData);
                expect(await body.text()).toBe(testData);
            });
            it("handle buffer", async () => {
                const testData = "foo";
                const body = new index_1.DataBody(Buffer.from(testData));
                setHash(body, testData);
                expect(await body.text()).toBe(testData);
            });
            it("handle stream", async () => {
                const testData = "foo";
                const stream = through2();
                stream.end(testData);
                const body = new index_1.StreamBody(stream);
                setHash(body, testData);
                expect(await body.text()).toBe(testData);
            });
        });
        describe("mismatching validation", () => {
            it("handle null", async () => {
                const body = new index_1.DataBody(null);
                setHash(body, "" + "x");
                expect(await makeSync(() => body.text()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle string", async () => {
                const testData = "foo";
                const body = new index_1.DataBody(testData);
                setHash(body, testData + "x");
                expect(await makeSync(() => body.text()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle buffer", async () => {
                const testData = "foo";
                const body = new index_1.DataBody(Buffer.from(testData));
                setHash(body, testData + "x");
                expect(await makeSync(() => body.text()))
                    .toThrow("Resource integrity mismatch");
            });
            it("handle stream", async () => {
                const testData = "foo";
                const stream = through2();
                stream.end(testData);
                const body = new index_1.StreamBody(stream);
                setHash(body, testData + "x");
                expect(await makeSync(() => body.text()))
                    .toThrow("Resource integrity mismatch");
            });
        });
    });
    describe("readable", () => {
        it("handle null", async () => {
            const body = new index_1.DataBody(null);
            const data = await get_stream_1.default.buffer(await body.readable());
            expect(data.toString()).toBe("");
        });
        it("handle string", async () => {
            const body = new index_1.DataBody("foo");
            const data = await get_stream_1.default.buffer(await body.readable());
            expect(data.toString()).toBe("foo");
        });
        it("handle buffer", async () => {
            const body = new index_1.DataBody(Buffer.from("foo"));
            const data = await get_stream_1.default.buffer(await body.readable());
            expect(data.toString()).toBe("foo");
        });
        it("handle stream", async () => {
            const stream = through2();
            stream.end("foo");
            const body = new index_1.StreamBody(stream);
            const data = await get_stream_1.default.buffer(await body.readable());
            expect(data.toString()).toBe("foo");
        });
    });
});
//# sourceMappingURL=body.js.map