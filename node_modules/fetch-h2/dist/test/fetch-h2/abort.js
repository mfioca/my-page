"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const index_1 = require("../../index");
const server_http1_1 = require("../lib/server-http1");
const server_http2_1 = require("../lib/server-http2");
const utils_1 = require("../lib/utils");
const protos = ["http1", "http2"];
async function makeServer(proto) {
    if (proto === "http1")
        return server_http1_1.makeServer();
    else if (proto === "http2")
        return server_http2_1.makeServer();
    return void 0;
}
const testProtos = protos.map(proto => ({
    makeServer: () => makeServer(proto),
    proto: proto === "http1" ? "http" : "http2",
    version: proto,
}));
describe("abort", () => {
    describe("AbortController", () => {
        it("should create proper signal and trigger abort once", async () => {
            const controller = new index_1.AbortController();
            const signal = controller.signal;
            const spy = jest.fn();
            signal.on("abort", spy);
            expect(signal.aborted).toBe(false);
            controller.abort();
            expect(signal.aborted).toBe(true);
            controller.abort();
            expect(signal.aborted).toBe(true);
            expect(spy.mock.calls.length).toBe(1);
        });
        it("should be destructable", async () => {
            const { signal, abort } = new index_1.AbortController();
            const spy = jest.fn();
            signal.on("abort", spy);
            expect(signal.aborted).toBe(false);
            abort();
            expect(signal.aborted).toBe(true);
            abort();
            expect(signal.aborted).toBe(true);
            expect(spy.mock.calls.length).toBe(1);
        });
        it("signal.onaborted should trigger once", async () => {
            const { signal, abort } = new index_1.AbortController();
            const spy = jest.fn();
            signal.onabort = spy;
            expect(signal.aborted).toBe(false);
            abort();
            expect(signal.aborted).toBe(true);
            abort();
            expect(signal.aborted).toBe(true);
            expect(spy.mock.calls.length).toBe(1);
        });
    });
    testProtos.forEach(({ proto, makeServer, version }) => describe(`fetch (${version})`, () => {
        it("should handle pre-aborted", async () => {
            const { signal, abort } = new index_1.AbortController();
            const { server, port } = await makeServer();
            abort();
            const awaitFetch = index_1.fetch(`${proto}://localhost:${port}/delay/100`, { signal });
            await expect(awaitFetch).rejects.toThrowError(index_1.AbortError);
            await server.shutdown();
        });
        it("should handle abort on request", async () => {
            const { signal, abort } = new index_1.AbortController();
            const { server, port } = await makeServer();
            setTimeout(abort, 20);
            const awaitFetch = index_1.fetch(`${proto}://localhost:${port}/delay/100`, { signal });
            await expect(awaitFetch).rejects.toThrowError(index_1.AbortError);
            await server.shutdown();
        });
        it("should handle abort on body", async () => {
            const { signal, abort } = new index_1.AbortController();
            const { server, port } = await makeServer();
            setTimeout(abort, 50);
            const response = utils_1.ensureStatusSuccess(await index_1.fetch(`${proto}://localhost:${port}/slow/100`, { signal }));
            const awaitBody = response.arrayBuffer();
            await expect(awaitBody).rejects.toThrowError(index_1.AbortError);
            await server.shutdown();
        });
    }));
});
//# sourceMappingURL=abort.js.map