"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const http_1 = require("http");
const http2_1 = require("http2");
const https_1 = require("https");
const crypto_1 = require("crypto");
const zlib_1 = require("zlib");
const already_1 = require("already");
const get_stream_1 = require("get-stream");
const server_common_1 = require("./server-common");
// These are the same in HTTP/1 and HTTP/2
const { HTTP2_HEADER_ACCEPT_ENCODING, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_SET_COOKIE, } = http2_1.constants;
class ServerHttp1 extends server_common_1.TypedServer {
    constructor(opts) {
        super();
        this._store = new Set();
        this._opts = opts || {};
        if (this._opts.serverOptions)
            this._server = https_1.createServer(this._opts.serverOptions);
        else
            this._server = http_1.createServer();
        this.port = null;
        this._server.on("connection", socket => { this._store.add(socket); });
        this._server.on("request", (request, response) => {
            this.onRequest(request, response)
                .catch(err => {
                console.error("Unit test server failed", err);
                process.exit(1);
            });
        });
    }
    async _shutdown() {
        for (const socket of this._store) {
            socket.destroy();
        }
        this._store.clear();
    }
    async onRequest(request, response) {
        const { url: path, headers } = request;
        let m;
        if (path == null)
            throw new Error("Internal test error");
        const sendHeaders = (headers) => {
            const { ":status": status = 200, ...rest } = { ...headers };
            response.statusCode = status;
            for (const [key, value] of Object.entries(rest))
                response.setHeader(key, value);
        };
        if (path === "/headers") {
            sendHeaders({
                ":status": 200,
                "content-type": "application/json",
            });
            response.end(JSON.stringify(headers));
        }
        else if (path === "/echo") {
            const responseHeaders = {
                ":status": 200,
            };
            [HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_CONTENT_LENGTH]
                .forEach(name => {
                const value = headers[name];
                if (value != null)
                    responseHeaders[name] = value;
            });
            sendHeaders(responseHeaders);
            request.pipe(response);
        }
        else if (path === "/set-cookie") {
            const responseHeaders = {
                ":status": 200,
                [HTTP2_HEADER_SET_COOKIE]: [],
            };
            const data = await get_stream_1.default.buffer(request);
            const json = JSON.parse(data.toString());
            json.forEach((cookie) => {
                responseHeaders[HTTP2_HEADER_SET_COOKIE]
                    .push(cookie);
            });
            sendHeaders(responseHeaders);
            response.end();
        }
        // tslint:disable-next-line
        else if (m = path.match(/\/wait\/(.+)/)) {
            const timeout = parseInt(m[1], 10);
            await already_1.delay(timeout);
            const responseHeaders = {
                ":status": 200,
            };
            [HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_CONTENT_LENGTH]
                .forEach(name => {
                const value = headers[name];
                if (value != null)
                    responseHeaders[name] = value;
            });
            try {
                sendHeaders(responseHeaders);
                request.pipe(response);
            }
            catch (err) 
            // We ignore errors since this route is used to intentionally
            // timeout, which causes us to try to write to a closed stream.
            { }
        }
        else if (path === "/trailers") {
            const responseHeaders = {
                ":status": 200,
            };
            const data = await get_stream_1.default.buffer(request);
            const json = JSON.parse(data.toString());
            sendHeaders(responseHeaders);
            response.write("trailers will be sent");
            response.addTrailers(json);
            response.end();
        }
        else if (path === "/sha256") {
            const hash = crypto_1.createHash("sha256");
            const responseHeaders = {
                ":status": 200,
            };
            sendHeaders(responseHeaders);
            hash.on("readable", () => {
                const data = hash.read();
                if (data) {
                    response.write(data.toString("hex"));
                    response.end();
                }
            });
            request.pipe(hash);
        }
        else if (path.startsWith("/compressed/")) {
            const encoding = path.replace("/compressed/", "");
            const accept = headers[HTTP2_HEADER_ACCEPT_ENCODING];
            if (!accept.includes(encoding)) {
                response.end();
                return;
            }
            const encoder = encoding === "gzip"
                ? zlib_1.createGzip()
                : encoding === "deflate"
                    ? zlib_1.createDeflate()
                    : encoding === "br"
                        ? zlib_1.createBrotliCompress()
                        : null;
            const responseHeaders = {
                ":status": 200,
                "content-encoding": encoding,
            };
            sendHeaders(responseHeaders);
            if (encoder)
                request.pipe(encoder).pipe(response);
            else
                request.pipe(response);
        }
        else if (path.startsWith("/delay/")) {
            const waitMs = parseInt(path.replace("/delay/", ""), 10);
            if (waitMs > 0)
                await already_1.delay(waitMs);
            const responseHeaders = {
                ":status": 200,
                [HTTP2_HEADER_CONTENT_LENGTH]: "10",
            };
            sendHeaders(responseHeaders);
            response.write("abcde");
            server_common_1.ignoreError(() => response.write("fghij"));
            server_common_1.ignoreError(() => response.end());
        }
        else if (path.startsWith("/slow/")) {
            const waitMs = parseInt(path.replace("/slow/", ""), 10);
            const responseHeaders = {
                ":status": 200,
                [HTTP2_HEADER_CONTENT_LENGTH]: "10",
            };
            sendHeaders(responseHeaders);
            response.write("abcde");
            if (waitMs > 0)
                await already_1.delay(waitMs);
            server_common_1.ignoreError(() => response.write("fghij"));
            server_common_1.ignoreError(() => response.end());
        }
        else if (path.startsWith("/prem-close")) {
            request.socket.destroy();
        }
        else {
            response.end();
        }
    }
}
exports.ServerHttp1 = ServerHttp1;
async function makeServer(opts = {}) {
    opts = opts || {};
    const server = new ServerHttp1(opts);
    await server.listen(opts.port);
    return { server, port: server.port };
}
exports.makeServer = makeServer;
//# sourceMappingURL=server-http1.js.map